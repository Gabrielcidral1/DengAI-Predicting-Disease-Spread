---
title: "DengAI-Predicting-Disease-Spread"
author: "gabriel"
date: "8/7/2019"
output:
  rmdformats::readthedown:
    thumbnails: true
    lightbox: true
    toc_depth: 3
    gallery: true
    highlight: tango
---
---

## loading packages and data

```{r, warning=F}
pacman:: p_load(readr, h2o, dplyr,ggplot2, caret, imputTS, randomForest, prophet, data.table, lubridate)

features_tr <- read_csv("dengue_features_train.csv", 
    col_types = cols(week_start_date = col_date(format = "%Y-%m-%d")))

labels_tr <- read_csv("dengue_labels_train.csv")

features_te <- read_csv("dengue_features_test.csv", 
    col_types = cols(week_start_date = col_date(format = "%Y-%m-%d")))

submission_format <- read_csv("submission_format.csv")

```

create two dataset, train and test

```{r}

train <- left_join(x = features_tr, y = labels_tr, by = c("year", "weekofyear", "city"))


test <- left_join(x = features_te, y = submission_format, by = c("year", "weekofyear", "city"))

```

### Inital investigation

```{r}
summary(train)

summary(test)

```

## Checking distrutions

the plots below confirm that most of the predictors haves similar distributions across train and test

```{r}

train$type <- "train"

test$type <- "test"

all <- rbind(train, test)

for (i in names(all)) {
x <- ggplot(data = all,aes_string(i,color="type")) + geom_density()
print(x)
}
```

### treat NAs

Plot line with Nas and one with a forecast (Kalman)
```{r}

ggplot(data = train, aes(week_start_date, ndvi_ne)) + geom_line()

imputeTS::na.kalman(train$ndvi_ne)

ggplot(data = train, aes(x = week_start_date, imputeTS::na.kalman(train$ndvi_ne))) + geom_line()

```

The missing values will be replaced by a forecast

```{r}


train <- cbind(train[ , c("city", "type", "week_start_date")] ,  apply(X = train[, which(sapply(train,is.numeric))], MARGIN = 2, function(x) imputeTS::na.kalman(x)))


```

```{r}
ggplot(filter(all, city=="sj"), aes(week_start_date, y = total_cases)) + geom_line()
ggplot(filter(all, city=="iq"), aes(week_start_date, y = total_cases)) + geom_line()

```


## split the cities to train models

San Juan
```{r}
sj <-  train %>% filter(city == "sj") 

sj$total_cases[sj$total_cases > 100] <- 100 

training_size <- createDataPartition(sj$total_cases, p = 0.7, list = F)  

sj_tr <- sj[training_size, ]

sj_val <- sj[-training_size, ]


```

Iquito

```{r}
iq <- train %>% filter(city == "iq")

iq$total_cases[iq$total_cases > 30] <- 30



training_size <- createDataPartition(iq$total_cases, p = 0.7, list = F)  

iq_tr <- iq[training_size, ]

iq_val <- iq[-training_size, ]

```

# Modelling San Juan




Get most relevant variables with all data (Var imp)

```{r}

names(sj)
sj$city <- NULL


rf_reg <- randomForest(y=sj$total_cases,x=sj[2:23],importance=T,method="rf") # starting in 2 to not use the variable "type"

imp <- as.data.frame(varImp(rf_reg))
imp <- data.frame(overall = imp$Overall,
           names   = rownames(imp))
x <- imp[order(imp$overall,decreasing = T),]

x$names <- as.character(x$names)


imp[order(imp$overall,decreasing = T),]

```
train model 

```{r}



sj_tr$city <- NULL

sj_tr$type <- NULL

# Get the best mtry
names(sj_tr)

bestmtry_rf <- tuneRF(x = sj_tr[ , head(unique(x$names),6)], y = sj_tr$total_cases, ntreeTry=100,stepFactor=2,improve=0.05,trace=TRUE, plot=T) 

# Train a random forest using that mtry
rf_reg<-randomForest(y=sj_tr$total_cases,x=sj_tr[ , head(unique(x$names),6)],importance=T,method="rf", ntree=100, mtry=8)


```

### Predict in validation

```{r}

names(sj_val)

pred_sj_val <- predict(rf_reg, sj_val)

postResample(pred_sj_val, sj_val$total_cases)

```

train model to predict Test (All train)

```{r}

# Get the best mtry
bestmtry_rf<-tuneRF(sj[ , head(unique(x$names),6)], sj$total_cases, ntreeTry=100,stepFactor=2,improve=0.05,trace=TRUE, plot=T) 

# Train a random forest using that mtry
rf_reg<-randomForest(y=sj$total_cases,x=sj[ , head(unique(x$names),6)],importance=T,method="rf", ntree=100, mtry=6)


```

### Make final prediction for San Juan (test)

```{r}

sj_te <- test %>% filter(city == "sj")


```

The missing values will be replaced by a forecast

```{r}

sj_te <- cbind(sj_te[ , c("city", "type", "week_start_date")] ,  apply(X = sj_te[, which(sapply(sj_te,is.numeric))], MARGIN = 2, function(x) imputeTS::na.kalman(x)))


```

```{r}

sj_te$total_cases <- predict(rf_reg, sj_te)

names(sj_te)
names(sj_tr)

#ggplot(rbind(sj_tr,sj_te), aes(week_start_date,total_cases)) + geom_line()


```

# Modelling Iquito

Get most relevant variables (Var imp)

```{r}



iq_tr$city <- NULL

rf_reg<-randomForest(y=iq$total_cases,x=iq[3:23],importance=T,method="rf")

imp <- as.data.frame(varImp(rf_reg))
imp <- data.frame(overall = imp$Overall,
           names   = rownames(imp))
x <- imp[order(imp$overall,decreasing = T),]

x$names <- as.character(x$names)

```
train model 

```{r}

# Get the best mtry
bestmtry_rf<-tuneRF(iq_tr[ , head(unique(x$names),6)], iq_tr$total_cases, ntreeTry=100,stepFactor=2,improve=0.05,trace=TRUE, plot=T) 

# Train a random forest using that mtry
rf_reg<-randomForest(y=iq_tr$total_cases,x=iq_tr[ , head(unique(x$names),6)],importance=T,method="rf", ntree=100, mtry=4)


```

predict in validation

```{r}

pred_iq_val <- predict(object = rf_reg, iq_val)

postResample(pred_iq_val, iq_val$total_cases)

```

train model to predict Test (All train)

```{r}

# Get the best mtry
bestmtry_rf<-tuneRF(iq[ , head(unique(x$names),6)], iq$total_cases, ntreeTry=100,stepFactor=2,improve=0.05,trace=TRUE, plot=T) 

# Train a random forest using that mtry
rf_reg<-randomForest(y=iq$total_cases,x=iq[ , head(unique(x$names),6)],importance=T,method="rf", ntree=100, mtry=6)

```

### Make final prediction for Iquito (test)

```{r}

iq_te <- test %>% filter(city == "iq")

```

The missing values will be replaced by a forecast

```{r}

iq_te <- cbind(iq_te[ , c("city", "type", "week_start_date")] ,  apply(X = iq_te[, which(sapply(iq_te,is.numeric))], MARGIN = 2, function(x) imputeTS::na.kalman(x)))


```

```{r}

iq_te$total_cases <- predict(rf_reg, iq_te)

```

# Final Submission using RF

```{r}
names(iq_te)

rf_final_df <- rbind(iq_te, sj_te)

submission_format$total_cases <- NULL

submission_rf <- left_join(submission_format, y = rf_final_df, by = c("year","weekofyear", "city"))

submission_rf <- submission_rf %>% select(city, year, weekofyear, total_cases)

submission_rf$total_cases <- base::round(submission_rf$total_cases,0)

write.csv(submission_rf, "submission_rf.csv", quote = F, row.names = F)

```



# Prophet San Juan


```{r}

sj_prophet <- setnames(sj, c("week_start_date", "total_cases"),new = c("ds","y"))

sj_prohet_model <- prophet(sj_prophet)

future <- make_future_dataframe(sj_prohet_model, 500, freq = "week")

forecast <- predict(sj_prohet_model, future)

forecast$year <- year(forecast$ds)

forecast$weekofyear <- week(forecast$ds)



dyplot.prophet(x = sj_prohet_model, fcst = forecast)

```

### Match Prophet and submission

```{r}


forecast$ds <- as.Date(forecast$ds)

forecast$city <- "sj"

forecast_sj <- forecast

submission <- left_join(submission_format, y = forecast[ , c("ds","weekofyear","year", "yhat", "city")], by = c("year","weekofyear", "city"))



```

# Prophet Iquito



```{r}

iq_prophet <- setnames(iq, c("week_start_date", "total_cases"),new = c("ds","y"))

iq_prohet_model <- prophet(iq_prophet)

future <- make_future_dataframe(iq_prohet_model, 500, freq = "week")

forecast <- predict(iq_prohet_model, future)

forecast$year <- year(forecast$ds)

forecast$weekofyear <- week(forecast$ds)


dyplot.prophet(x = iq_prohet_model, fcst = forecast)

```

### Match Prophet and submission

```{r}


forecast$ds <- as.Date(forecast$ds)

forecast$city <- "iq"

forecast <- rbind(forecast_sj, forecast)

submission <- left_join(submission_format, y = forecast[ , c("ds","weekofyear","year", "yhat", "city")], by = c("year","weekofyear", "city"))

submission$yhat <- imputeTS::na.kalman(submission$yhat) # fill NAs due to 53 week year


```

### Change negative values to 0

```{r}

submission$yhat[submission$yhat < 0 ] <- 0

submission$total_cases <- submission$yhat

submission <- submission %>% select(city, year, weekofyear, total_cases)

submission$total_cases <- base::round(submission$total_cases,0)

write.csv(submission, "submission.csv", quote = F, row.names = F)



```


## Final final submission with the mean of both previous

```{r}

submission_mean <- submission 

a <- cbind(submission$total_cases, submission_rf$total_cases)

submission_mean$total_cases <- round(apply(X = a, MARGIN = 1, function(x) mean(x)),0)

write.csv(submission_mean, "submission_mean.csv", quote = F, row.names = F)

  
```

